/// <reference types="node" />
import type babelCore from '@babel/core';
import type { Primitive } from 'type-fest';
declare type CodegenModuleExport = string | ((...args: Array<any>) => string);
declare type CompiledESModule = {
    __esModule: boolean;
    default: CodegenModuleExport;
};
declare const getFilename: (fileOpts: babelCore.TransformOptions) => string;
declare function requireFromString(code: string | Buffer, filename: string): string | ((...args: any[]) => string) | CompiledESModule;
declare type GetReplacementOptions = {
    code: string | Buffer;
    fileOpts: babelCore.TransformOptions;
    args?: Array<any>;
};
declare function getReplacement({ code, fileOpts, args }: GetReplacementOptions, babel: typeof babelCore): babelCore.types.BlockStatement | babelCore.types.BreakStatement | babelCore.types.ContinueStatement | babelCore.types.DebuggerStatement | babelCore.types.DoWhileStatement | babelCore.types.EmptyStatement | babelCore.types.ExpressionStatement | babelCore.types.ForInStatement | babelCore.types.ForStatement | babelCore.types.FunctionDeclaration | babelCore.types.IfStatement | babelCore.types.LabeledStatement | babelCore.types.ReturnStatement | babelCore.types.SwitchStatement | babelCore.types.ThrowStatement | babelCore.types.TryStatement | babelCore.types.VariableDeclaration | babelCore.types.WhileStatement | babelCore.types.WithStatement | babelCore.types.ClassDeclaration | babelCore.types.ExportAllDeclaration | babelCore.types.ExportDefaultDeclaration | babelCore.types.ExportNamedDeclaration | babelCore.types.ForOfStatement | babelCore.types.ImportDeclaration | babelCore.types.DeclareClass | babelCore.types.DeclareFunction | babelCore.types.DeclareInterface | babelCore.types.DeclareModule | babelCore.types.DeclareModuleExports | babelCore.types.DeclareTypeAlias | babelCore.types.DeclareOpaqueType | babelCore.types.DeclareVariable | babelCore.types.DeclareExportDeclaration | babelCore.types.DeclareExportAllDeclaration | babelCore.types.InterfaceDeclaration | babelCore.types.OpaqueType | babelCore.types.TypeAlias | babelCore.types.EnumDeclaration | babelCore.types.TSDeclareFunction | babelCore.types.TSInterfaceDeclaration | babelCore.types.TSTypeAliasDeclaration | babelCore.types.TSEnumDeclaration | babelCore.types.TSModuleDeclaration | babelCore.types.TSImportEqualsDeclaration | babelCore.types.TSExportAssignment | babelCore.types.TSNamespaceExportDeclaration | babelCore.types.Statement[];
declare type ReplaceOptions<SpecificNode extends babelCore.types.Node> = {
    path: babelCore.NodePath<SpecificNode>;
    code: string | Buffer;
    fileOpts: babelCore.TransformOptions;
    args?: Array<any>;
};
declare function replace<SpecificNode extends babelCore.types.Node>({ path, code, fileOpts, args }: ReplaceOptions<SpecificNode>, babel: typeof babelCore): void;
declare function resolveModuleContents({ filename, module, }: {
    filename: string;
    module: string;
}): {
    code: Buffer;
    resolvedPath: string;
};
declare function isCodegenComment(comment: babelCore.types.Comment): boolean;
declare function isPropertyCall(path: babelCore.NodePath, name: string): boolean;
declare type LooksLikeTarget = any;
declare type LooksLikeMatch = Primitive | ((a: LooksLikeTarget) => boolean) | {
    [key: string]: LooksLikeMatch;
};
declare function looksLike(a: LooksLikeTarget, b: LooksLikeMatch): boolean;
export { requireFromString, getReplacement, replace, resolveModuleContents, isCodegenComment, isPropertyCall, looksLike, getFilename, };
